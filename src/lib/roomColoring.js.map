{"version":3,"file":"roomColoring.js","sourceRoot":"","sources":["roomColoring.ts"],"names":[],"mappings":"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","sourcesContent":["// src/lib/roomColoring.ts\r\n\r\n/**\r\n * Standard Roborock color palette (Dark Mode style).\r\n * Index 0 is the background/default. Indices 1-4 are the main room colors.\r\n */\r\nexport const ROBOROCK_PALETTE = [\r\n\t\"#DFDFDFff\", // 0: Default (background/no color)\r\n\t\"#50A4FF\", // 1: Blue\r\n\t\"#FF744D\", // 2: Orange\r\n\t\"#008FA8\", // 3: Cyan\r\n\t\"#F5AF10\", // 4: Yellow\r\n\t\"#E9E9E9ff\", // 5: Reserve/Fallback\r\n];\r\n\r\n/**\r\n * Defines the input data required for the coloring algorithm.\r\n */\r\nexport interface ColoringData {\r\n\t/** The highest segment ID (defines the size of the adjacency matrix). Usually 32. */\r\n\tmaxBlockNum: number;\r\n\t/**\r\n\t * A flat (row-major) adjacency matrix (size * size).\r\n\t * neighborInfo[a * size + b] === 1 if room 'a' and room 'b' are neighbors.\r\n\t */\r\n\tneighborInfo: number[];\r\n\t/** An array storing the pixel count (area) for each segment ID. */\r\n\tpointsCount: number[];\r\n}\r\n\r\n/**\r\n * Defines the options for the coloring algorithm.\r\n */\r\nexport interface ColoringOptions {\r\n\t/** Whether segment IDs start at 1 (Roborock standard). */\r\n\toneBased: boolean;\r\n}\r\n\r\n/**\r\n * Return structure containing the assignment results.\r\n */\r\nexport interface ColoringResult {\r\n\t/** Maps room ID to a logical color bucket index (1-4). */\r\n\tcolorBucket: number[];\r\n\t/** Maps room ID to the final hex color string. */\r\n\tcolorHex: string[];\r\n}\r\n\r\n/**\r\n * Assigns colors to rooms based on the Roborock graph coloring algorithm.\r\n * Ensures that adjacent rooms receive different colors where possible.\r\n * @param data The room topology and neighbor data.\r\n * @param options Configuration options (e.g. is index 1-based?).\r\n * @returns The color assignments (buckets and hex codes).\r\n */\r\nexport function assignRoborockRoomColorsToHex(data: ColoringData, options: ColoringOptions): ColoringResult {\r\n\tconst { maxBlockNum, neighborInfo, pointsCount } = data;\r\n\tconst { oneBased } = options;\r\n\r\n\tconst numColors = 4; // Algorithm is strictly designed for 4 colors + 1 \"no color\"\r\n\tconst idOffset = oneBased ? 1 : 0;\r\n\tconst matrixSize = maxBlockNum;\r\n\r\n\t// colorData stores the assigned logical color index (1-4) for each room ID.\r\n\tconst colorData = new Array(matrixSize).fill(0);\r\n\r\n\t// 1. Calculate neighbor counts for each room to prioritize coloring\r\n\t// [roomID, neighborCount]\r\n\tconst neighbourColorSet: [number, number][] = [];\r\n\r\n\tfor (let i = idOffset; i < matrixSize; i++) {\r\n\t\tlet count = 0;\r\n\t\tfor (let j = idOffset; j < matrixSize; j++) {\r\n\t\t\tif (i !== j && neighborInfo[i * matrixSize + j] === 1) {\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tneighbourColorSet.push([i, count]);\r\n\t}\r\n\r\n\t// Sort rooms by number of neighbors descending (most connected rooms first)\r\n\tneighbourColorSet.sort((a, b) => b[1] - a[1]);\r\n\r\n\t// 2. Find the largest room by area (pixel count)\r\n\tlet maxIndex = 0;\r\n\tlet maxPointsCount = 0;\r\n\r\n\tfor (let i = idOffset; i < matrixSize; i++) {\r\n\t\tif (pointsCount[i] > maxPointsCount) {\r\n\t\t\tmaxPointsCount = pointsCount[i];\r\n\t\t\tmaxIndex = i;\r\n\t\t}\r\n\t}\r\n\r\n\t// 3. Assign the first color (index 1) to the largest room immediately\r\n\tif (maxIndex >= idOffset && maxIndex < matrixSize) {\r\n\t\tcolorData[maxIndex] = 1;\r\n\t}\r\n\r\n\t// Buckets for tracking which rooms are assigned to which color index (0-3 mapped to colors 1-4)\r\n\tconst colorUsed: number[][] = Array.from({ length: numColors }, () => []);\r\n\r\n\tif (maxIndex >= idOffset && maxIndex < matrixSize) {\r\n\t\tcolorUsed[0].push(maxIndex);\r\n\t}\r\n\r\n\t// 4. Main Greedy Coloring Loop\r\n\tfor (const [roomId] of neighbourColorSet) {\r\n\t\t// Skip the largest room as it is already colored\r\n\t\tif (roomId === maxIndex) continue;\r\n\r\n\t\t// Check if the room actually exists (diagonal element must be 1, or check logic)\r\n\t\t// If neighborInfo[i][i] == 0, the room is considered empty/non-existent\r\n\t\tif (neighborInfo[roomId * matrixSize + roomId] === 0) {\r\n\t\t\tcolorData[roomId] = 0;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t// Determine which colors are blocked by neighbors\r\n\t\tconst colorOccupied = new Array(numColors + 1).fill(0);\r\n\r\n\t\tfor (const [otherRoomId] of neighbourColorSet) {\r\n\t\t\t// If 'otherRoomId' is a neighbor of 'roomId' AND has a color assigned\r\n\t\t\tif (neighborInfo[otherRoomId * matrixSize + roomId] !== 0 && colorData[otherRoomId] !== 0) {\r\n\t\t\t\tcolorOccupied[colorData[otherRoomId]] = 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Find the first available color (1-4)\r\n\t\tlet assigned = false;\r\n\t\tfor (let j = 1; j <= numColors; j++) {\r\n\t\t\tif (colorOccupied[j] === 0) {\r\n\t\t\t\tcolorData[roomId] = j;\r\n\t\t\t\tcolorUsed[j - 1].push(roomId);\r\n\t\t\t\tassigned = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Fallback: If all colors are taken, force color 1\r\n\t\tif (!assigned) {\r\n\t\t\tcolorData[roomId] = 1;\r\n\t\t\tif (colorUsed[0]) {\r\n\t\t\t\tcolorUsed[0].push(roomId);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// --- START: Balancing Logic (Distribute colors evenly) ---\r\n\r\n\t// 5. First Balancing Step: Fill empty color buckets\r\n\tfor (let i = 0; i < numColors; i++) {\r\n\t\tif (colorUsed[i].length === 0) {\r\n\t\t\tconst sourceID = Math.floor((i + 1) / 2) - 1;\r\n\r\n\t\t\tif (sourceID < 0 || sourceID >= numColors || colorUsed[sourceID].length <= 1) continue;\r\n\r\n\t\t\tconst sourceLength = colorUsed[sourceID].length;\r\n\t\t\tconst startIndex = Math.floor(sourceLength / 2);\r\n\r\n\t\t\tconst itemsToMove: number[] = [];\r\n\t\t\tfor (let j = sourceLength - 1; j >= startIndex; j--) {\r\n\t\t\t\titemsToMove.push(colorUsed[sourceID][j]);\r\n\t\t\t}\r\n\r\n\t\t\tfor (let k = itemsToMove.length - 1; k >= 0; k--) {\r\n\t\t\t\tcolorUsed[i].push(itemsToMove[k]);\r\n\t\t\t}\r\n\r\n\t\t\tfor (let j = 0; j < itemsToMove.length; j++) {\r\n\t\t\t\tcolorUsed[sourceID].pop();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// 6. Second Balancing Step: Move from largest bucket to empty bucket\r\n\tlet maxLength = 0;\r\n\tlet maxID = 0;\r\n\tlet zeroID = -1;\r\n\r\n\tfor (let i = 0; i < numColors; i++) {\r\n\t\tif (colorUsed[i].length > maxLength) {\r\n\t\t\tmaxLength = colorUsed[i].length;\r\n\t\t\tmaxID = i;\r\n\t\t}\r\n\t\tif (colorUsed[i].length === 0) zeroID = i;\r\n\t}\r\n\r\n\tif (maxLength >= 2 && zeroID !== -1) {\r\n\t\twhile (colorUsed[maxID].length > colorUsed[zeroID].length) {\r\n\t\t\tconst itemToMove = colorUsed[maxID].pop();\r\n\t\t\tif (itemToMove !== undefined) {\r\n\t\t\t\tcolorUsed[zeroID].push(itemToMove);\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// --- END: Balancing Logic ---\r\n\r\n\t// 7. Final Assignment: Rewrite colorData based on balanced buckets\r\n\tfor (let i = 0; i < numColors; i++) {\r\n\t\tfor (const blockIndex of colorUsed[i]) {\r\n\t\t\tif (blockIndex >= 0 && blockIndex < matrixSize) {\r\n\t\t\t\tcolorData[blockIndex] = i + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// 8. Generate Hex Colors\r\n\tconst colorHex = new Array(matrixSize).fill(ROBOROCK_PALETTE[0]);\r\n\r\n\tfor (let i = idOffset; i < matrixSize; i++) {\r\n\t\tconst colorIndex = colorData[i];\r\n\r\n\t\tif (colorIndex > 0 && colorIndex < ROBOROCK_PALETTE.length) {\r\n\t\t\tcolorHex[i] = ROBOROCK_PALETTE[colorIndex];\r\n\t\t} else if (colorIndex !== 0) {\r\n\t\t\t// Fallback for indices outside range (wrap around 1-4)\r\n\t\t\tcolorHex[i] = ROBOROCK_PALETTE[1 + ((colorIndex - 1) % numColors)];\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcolorBucket: colorData,\r\n\t\tcolorHex: colorHex,\r\n\t};\r\n}\r\n"]}