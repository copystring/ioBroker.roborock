{"version":3,"file":"protocol.test.js","sourceRoot":"","sources":["../../../src/lib/mock/protocol.test.ts"],"names":[],"mappings":"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","sourcesContent":["\r\nimport { expect } from \"chai\";\r\nimport { MockAdapter } from \"./MockAdapter\";\r\nimport { messageParser } from \"../messageParser\"; // Real class\r\nimport * as crc32 from \"crc-32\";\r\n\r\ndescribe(\"Protocol Deep Dive (messageParser)\", () => {\r\n\tlet mockAdapter: MockAdapter;\r\n\tlet parser: messageParser;\r\n\r\n\tbeforeEach(() => {\r\n\t\tmockAdapter = new MockAdapter();\r\n\t\tmockAdapter.http_api = {\r\n\t\t\tgetMatchedLocalKeys: () => new Map([[\"duid\", Buffer.from(\"3641643966536967756e447950543255\", \"hex\")]])\r\n\t\t} as any;\r\n\t\tparser = new messageParser(mockAdapter as any);\r\n\t\t// Mock crypto engine if needed, but we can verify CRC/Header without decrypting if we mock dependencies\r\n\t\t// Actually, decodeMsg calls decryptors.\r\n\t\t// We'll need to mock crypto or handle the throwing.\r\n\t});\r\n\r\n\tit(\"should reject invalid CRC\", () => {\r\n\t\t// Construct a fake frame\r\n\t\t// const header = Buffer.alloc(23); // Header len 19 + CRC 4? No, header is 19.\r\n\t\t// 3(ver) + 4(seq) + 4(rnd) + 4(ts) + 2(proto) + 2(len) = 19. + Payload + 4(CRC).\r\n\r\n\t\tconst buf = Buffer.alloc(19 + 5 + 4); // 5 bytes payload\r\n\t\tbuf.write(\"1.0\");\r\n\t\tbuf.writeUInt32BE(1, 3);\r\n\t\tbuf.writeUInt32BE(1234, 7);\r\n\t\tbuf.writeUInt32BE(99999, 11);\r\n\t\tbuf.writeUInt16BE(4, 15);\r\n\t\tbuf.writeUInt16BE(5, 17);\r\n\t\tbuf.write(\"hello\", 19);\r\n\r\n\t\t// Write INVALID CRC\r\n\t\tbuf.writeUInt32BE(0xDEADBEEF, 19 + 5);\r\n\r\n\t\tconst decoded = parser.decodeMsg(buf, \"duid\");\r\n\t\t// Log error is called, returns null\r\n\t\texpect(decoded).to.be.null; // Or [] depending on implementation\r\n\t});\r\n\r\n\tit(\"should accept valid CRC\", () => {\r\n\t\tconst buf = Buffer.alloc(19 + 5 + 4);\r\n\t\tbuf.write(\"1.0\");\r\n\t\tbuf.writeUInt32BE(1, 3);\r\n\t\tbuf.writeUInt32BE(1234, 7);\r\n\t\tbuf.writeUInt32BE(99999, 11);\r\n\t\tbuf.writeUInt16BE(4, 15);\r\n\t\tbuf.writeUInt16BE(5, 17);\r\n\t\tbuf.write(\"hello\", 19);\r\n\r\n\t\t// Calculate valid CRC\r\n\t\tconst crcValue = crc32.buf(buf.subarray(0, buf.length - 4)) >>> 0;\r\n\t\tbuf.writeUInt32BE(crcValue, buf.length - 4);\r\n\r\n\t\t// We expect decryption to fail (we didn't mock crypto fully), but CRC check comes BEFORE decryption.\r\n\t\t// In decodeMsg: Validate CRC -> Get Key -> Decrypt.\r\n\t\t// So checking logs for \"Decryption failed\" vs \"CRC mismatch\" separates the two.\r\n\r\n\t\tlet logError = \"\";\r\n\t\tmockAdapter.log.error = (msg: string) => { logError = msg; };\r\n\r\n\t\tparser.decodeMsg(buf, \"duid\");\r\n\r\n\t\t// If passed CRC, it proceeds to decryption.\r\n\t\texpect(logError).to.include(\"Decryption\");\r\n\t\texpect(logError).to.not.include(\"CRC32 mismatch\");\r\n\t});\r\n});\r\n"]}