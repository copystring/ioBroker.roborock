{"version":3,"file":"MockAdapter.js","sourceRoot":"","sources":["../../../src/lib/mock/MockAdapter.ts"],"names":[],"mappings":"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","sourcesContent":["\nexport class MockAdapter {\n\tpublic objects: Record<string, any> = {};\n\tpublic states: Record<string, any> = {};\n\tpublic log: any;\n\tpublic config: any = {};\n\tpublic requestsHandler: any;\n\tpublic mqtt_api: any;\n\tpublic local_api: any;\n\tpublic http_api: any;\n\t// mock support methods\n\tpublic instance: number = 0;\n\tpublic pendingRequests: Map<number, any> = new Map();\n\tpublic nonce: Buffer = Buffer.alloc(16);\n\tpublic translations: Record<string, string> = {};\n\tpublic catchError(error: any, attribute: string): void {\n\t\tthis.log.error(`[CatchError] ${attribute}: ${error}`);\n\t}\n\tpublic setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): any { return setInterval(callback, ms, ...args); }\n\tpublic clearInterval(intervalId: any): void { clearInterval(intervalId); }\n\tpublic clearTimeout(timeoutId: any): void { clearTimeout(timeoutId); }\n\tpublic async getDeviceProtocolVersion(): Promise<string> { return \"1.0\"; }\n\n\tconstructor() {\n\t\tthis.log = {\n\t\t\tinfo: (msg: string) => console.log(`[INFO] ${msg}`),\n\t\t\twarn: (msg: string) => console.warn(`[WARN] ${msg}`),\n\t\t\terror: (msg: string) => console.error(`[ERROR] ${msg}`),\n\t\t\tdebug: () => {},\n\t\t\tsilly: () => {}\n\t\t};\n\t}\n\n\tpublic async setObjectAsync(id: string, obj: any): Promise<void> {\n\t\tthis.objects[id] = obj;\n\t}\n\n\tpublic async setObjectNotExistsAsync(id: string, obj: any): Promise<void> {\n\t\tif (!this.objects[id]) {\n\t\t\tthis.objects[id] = obj;\n\t\t}\n\t}\n\n\tpublic async extendObjectAsync(id: string, obj: any): Promise<void> {\n\t\tthis.objects[id] = { ...this.objects[id], ...obj };\n\t}\n\n\tpublic async extendObject(id: string, obj: any): Promise<void> {\n\t\tthis.objects[id] = { ...this.objects[id], ...obj };\n\t}\n\n\tpublic async getObjectAsync(id: string): Promise<any> {\n\t\treturn this.objects[id];\n\t}\n\n\tpublic async setObject(id: string, obj: any): Promise<void> {\n\t\tthis.objects[id] = obj;\n\t}\n\n\tpublic async setStateAsync(id: string, state: any): Promise<void> {\n\t\t// Handle { val: ... } object or direct value\n\t\tlet val = state;\n\t\tif (typeof state === \"object\" && state !== null && \"val\" in state) {\n\t\t\tval = state.val;\n\t\t}\n\n\t\tthis.states[id] = val;\n\n\t\t// Type Verification\n\t\tconst obj = this.objects[id];\n\t\tif (obj && obj.common && obj.common.type) {\n\t\t\tconst expectedType = obj.common.type;\n\t\t\tconst actualType = typeof val;\n\n\t\t\tif (expectedType === \"array\" || expectedType === \"object\") {\n\t\t\t\tif (actualType !== \"object\" && actualType !== \"string\") { // Strings are sometimes allowed for JSON\n\t\t\t\t\tthrow new Error(`Type mismatch for ${id}. Expected ${expectedType}, got ${actualType} (${val})`);\n\t\t\t\t}\n\t\t\t} else if (expectedType === \"mixed\") {\n\t\t\t\t// Any type allowable\n\t\t\t} else if (actualType !== expectedType) {\n\t\t\t\t// Allow number/string auto-conversion if simple\n\t\t\t\tif (expectedType === \"string\" && actualType === \"number\") return;\n\n\t\t\t\t// Optional: Allow null if not strictly forbidden? Usually ioBroker allows null.\n\t\t\t\tif (val === null || val === undefined) return;\n\n\t\t\t\t// Strict check for others\n\t\t\t\tthrow new Error(`Type mismatch for ${id}. Expected ${expectedType}, got ${actualType} (${val})`);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic async setStateChangedAsync(id: string, state: any): Promise<void> {\n\t\treturn this.setStateAsync(id, state);\n\t}\n\n\tpublic async getStateAsync(id: string): Promise<any> {\n\t\treturn { val: this.states[id], ack: true };\n\t}\n}\n"]}