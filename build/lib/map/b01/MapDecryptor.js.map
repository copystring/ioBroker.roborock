{"version":3,"file":"MapDecryptor.js","sourceRoot":"","sources":["../../../../src/lib/map/b01/MapDecryptor.ts"],"names":[],"mappings":"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","sourcesContent":["import * as crypto from \"crypto\";\nimport * as MapHelper from \"../MapHelper\";\nimport { cryptoEngine } from \"../../cryptoEngine\";\n\nexport class MapDecryptor {\n\n\t/**\n     * Decrypts B01 Map Buffer using the full verified pipeline (Layer 1 CBC -> L2 Base64 -> L3 ECB -> L4 HexBin -> L5 Decompress).\n     * Returns the raw Protobuf buffer if successful, or null/original if failed.\n     */\n\tstatic decrypt(buf: Buffer, serial: string, model: string, _duid: string, adapter?: any, localKey?: string): Buffer | null {\n\t\tMapDecryptor.logDebug(adapter, `Decrypting Block. Serial: ${serial}, Model: ${model}, Len: ${buf.length}`);\n\n\t\tif (MapDecryptor.isLikelyProtobuf(buf)) {\n\t\t\tMapDecryptor.logDebug(adapter, \"Input appears to be already decrypted (Protobuf). Returning as-is.\");\n\t\t\treturn buf;\n\t\t}\n\n\t\tlet current = buf;\n\n\t\t// 1. Layer 1: Outer Roborock Wrapper (B01Header + CBC)\n\t\tif (current.length > 19 && current.toString(\"ascii\", 0, 3) === \"B01\") {\n\t\t\ttry {\n\t\t\t\tconst ivSeed = current.readUInt32BE(7);\n\t\t\t\tconst payloadLen = current.readUInt16BE(17);\n\t\t\t\tconst payload = current.subarray(19, 19 + payloadLen);\n\n\t\t\t\tif (localKey) {\n\t\t\t\t\tconst derivedIV = cryptoEngine.deriveB01IV(ivSeed);\n\t\t\t\t\tconst decryptedCBC = MapDecryptor.decryptCBC(payload, localKey, derivedIV);\n\t\t\t\t\tif (decryptedCBC) {\n\t\t\t\t\t\tcurrent = decryptedCBC;\n\t\t\t\t\t\tMapDecryptor.logDebug(adapter, `Layer 1 Decrypted (CBC). Len=${current.length}. Header: ${current.subarray(0, 16).toString(\"hex\")}`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tMapDecryptor.logDebug(adapter, \"Layer 1 detected but no LocalKey provided. Skipping CBC.\");\n\t\t\t\t}\n\t\t\t} catch (e: any) {\n\t\t\t\tMapDecryptor.logDebug(adapter, `Layer 1 Decryption failed: ${e.message}`, \"warn\");\n\t\t\t}\n\t\t}\n\n\t\t// 2. Layer 2: Intermediate Base64 Wrap\n\t\ttry {\n\t\t\t// Check if buffer contains only safe Base64 ASCII characters\n\t\t\t// We check the first 1000 characters to be reasonably sure, or the whole buffer if small.\n\t\t\tconst checkLen = Math.min(current.length, 4096);\n\t\t\tlet isBase64 = true;\n\t\t\tfor (let i = 0; i < checkLen; i++) {\n\t\t\t\tconst byte = current[i];\n\t\t\t\t// A-Z, a-z, 0-9, +, /, =, whitespace\n\t\t\t\tif (\n\t\t\t\t\t(byte >= 65 && byte <= 90) || // A-Z\n\t\t\t\t\t(byte >= 97 && byte <= 122) || // a-z\n\t\t\t\t\t(byte >= 48 && byte <= 57) || // 0-9\n\t\t\t\t\tbyte === 43 || byte === 47 || byte === 61 || // + / =\n\t\t\t\t\tbyte === 10 || byte === 13 || byte === 32 // \\n \\r space\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisBase64 = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (isBase64 && current.length > 0) {\n\t\t\t\tconst asStr = current.toString(\"utf8\");\n\t\t\t\tconst decoded = Buffer.from(asStr, \"base64\");\n\t\t\t\t// Verify it actually decoded to something different\n\t\t\t\tif (decoded.length > 0 && decoded.length !== current.length) {\n\t\t\t\t\tcurrent = decoded;\n\t\t\t\t\tMapDecryptor.logDebug(adapter, `Layer 2: Base64 decoding applied. New Len=${current.length}. Header: ${current.subarray(0, 8).toString(\"hex\")}`);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e: any) {\n\t\t\tMapDecryptor.logDebug(adapter, `Layer 2 Base64 check failed: ${e.message}`, \"warn\");\n\t\t}\n\n\t\t// 3. Layer 3: Inner Cipher (ECB) with MapKey\n\t\tif (serial && model) {\n\t\t\ttry {\n\t\t\t\t// Safety: ECB requires 16-byte alignment\n\t\t\t\tif (current.length % 16 === 0) {\n\t\t\t\t\tconst mapKey = MapDecryptor.deriveMapKey(serial, model);\n\t\t\t\t\tconst innerDecrypted = MapDecryptor.decryptECB(current, mapKey);\n\t\t\t\t\tif (innerDecrypted && innerDecrypted.length > 0) {\n\t\t\t\t\t\tcurrent = innerDecrypted;\n\t\t\t\t\t\tMapDecryptor.logDebug(adapter, `Layer 3 Decrypted (ECB). Len=${current.length}. Header: ${current.subarray(0, 16).toString(\"hex\")}`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// It's not 16-byte aligned\n\t\t\t\t\tMapDecryptor.logDebug(adapter, `Skipping Layer 3 ECB: Data length ${current.length} is not a multiple of 16. Header: ${current.subarray(0, 8).toString(\"hex\")}...`, \"warn\");\n\t\t\t\t}\n\t\t\t} catch (e: any) {\n\t\t\t\tMapDecryptor.logDebug(adapter, `Layer 3 Decryption failed: ${e.message}`, \"warn\");\n\t\t\t}\n\t\t} else {\n\t\t\tMapDecryptor.logDebug(adapter, \"Missing Serial or Model, skipping Layer 3 ECB.\", \"warn\");\n\t\t}\n\n\t\t// 4. Layer 4: Hex-in-ASCII conversion\n\t\tconst checkStr = current.subarray(0, 10).toString(\"utf8\");\n\t\tif (/^[0-9a-fA-F]+$/.test(checkStr) && checkStr.startsWith(\"78\")) {\n\t\t\ttry {\n\t\t\t\tconst hexDecoded = Buffer.from(current.toString(\"utf8\"), \"hex\");\n\t\t\t\tif (hexDecoded.length > 0) {\n\t\t\t\t\tcurrent = hexDecoded;\n\t\t\t\t\tMapDecryptor.logDebug(adapter, `Layer 4 Hex->Bin conversion applied.`);\n\t\t\t\t}\n\t\t\t} catch {}\n\t\t}\n\n\t\t// 5. Layer 5: Decompression (GZIP/ZLIB)\n\t\tconst decompressed = MapHelper.decompress(current);\n\t\tif (decompressed === current && !MapDecryptor.isSignatureMatch(decompressed)) {\n\t\t\tMapDecryptor.logDebug(adapter, `Decompression skipped/failed. No known signature (Gzip/Zlib/Protobuf) found. Header: ${current.subarray(0, 8).toString(\"hex\")}`, \"warn\");\n\t\t}\n\t\tcurrent = decompressed;\n\n\t\t// Verification\n\t\tif (MapDecryptor.isPlaintext(current)) {\n\t\t\treturn current;\n\t\t}\n\n\t\treturn current;\n\t}\n\n\tprivate static deriveMapKey(serial: string, model: string): Buffer {\n\t\tconst modelSuffix = model.includes(\".\") ? (model.split(\".\").pop() as string) : model;\n\n\t\t// Standard key derivation\n\t\t// let p=x; while(p.length<16)p+=\"0\";\n\t\tlet p = modelSuffix;\n\t\twhile (p.length < 16) p += \"0\";\n\t\tconst key = Buffer.from(p.substring(0, 16), \"utf8\");\n\n\t\tconst inputStr = `${serial}+${modelSuffix}+${serial}`;\n\t\tconst inputBuf = Buffer.from(inputStr, \"utf8\");\n\n\t\t// Apply PKCS7 padding\n\t\t// const z=16-(Buffer.byteLength(t)%16),e=Buffer.concat([c.update(Buffer.concat([Buffer.from(t),Buffer.alloc(z,z)])),c.final()]);\n\t\tconst z = 16 - (inputBuf.length % 16);\n\t\tconst paddedInput = Buffer.concat([inputBuf, Buffer.alloc(z, z)]);\n\n\t\tconst cipher = crypto.createCipheriv(\"aes-128-ecb\", key, null);\n\t\tcipher.setAutoPadding(false);\n\n\t\tlet encrypted = cipher.update(paddedInput);\n\t\tencrypted = Buffer.concat([encrypted, cipher.final()]);\n\n\t\tconst hash = crypto.createHash(\"md5\").update(encrypted.toString(\"base64\")).digest(\"hex\");\n\t\treturn Buffer.from(hash.substring(8, 24).toLowerCase(), \"utf8\");\n\t}\n\n\tprivate static decryptECB(encrypted: Buffer, key: Buffer): Buffer {\n\t\t// Log key and input start\n\t\tconst decipher = crypto.createDecipheriv(\"aes-128-ecb\", key, null);\n\t\tdecipher.setAutoPadding(true);\n\t\tconst result = Buffer.concat([decipher.update(encrypted), decipher.final()]);\n\t\treturn result;\n\t}\n\n\tprivate static decryptCBC(encrypted: Buffer, key: string | Buffer, iv: Buffer): Buffer | null {\n\t\ttry {\n\t\t\tconst keyBuf = typeof key === \"string\" ? Buffer.from(key, \"utf8\") : key;\n\t\t\tconst decipher = crypto.createDecipheriv(\"aes-128-cbc\", keyBuf, iv);\n\t\t\tdecipher.setAutoPadding(true);\n\t\t\treturn Buffer.concat([decipher.update(encrypted), decipher.final()]);\n\t\t} catch {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static isSignatureMatch(buf: Buffer): boolean {\n\t\treturn MapHelper.isSignatureMatch(buf);\n\t}\n\n\tpublic static isLikelyProtobuf(buf: Buffer): boolean {\n\t\treturn MapHelper.isLikelyProtobuf(buf);\n\t}\n\n\tprivate static isPlaintext(buf: Buffer): boolean {\n\t\treturn this.isSignatureMatch(buf);\n\t}\n\n\tprivate static logDebug(adapter: any, msg: string, level: \"debug\" | \"warn\" | \"error\" = \"debug\"): void {\n\t\tif (adapter) {\n\t\t\tif (typeof adapter.rLog === \"function\") {\n\t\t\t\tadapter.rLog(\"System\", null, level === \"warn\" ? \"Warn\" : level === \"error\" ? \"Error\" : \"Debug\", \"B01Decrypt\", undefined, msg, level);\n\t\t\t} else if (adapter.log) {\n\t\t\t\tif (level === \"warn\") adapter.log.warn(`[B01Decrypt] ${msg}`);\n\t\t\t\telse if (level === \"error\") adapter.log.error(`[B01Decrypt] ${msg}`);\n\t\t\t\telse adapter.log.debug(`[B01Decrypt] ${msg}`);\n\t\t\t}\n\t\t}\n\t}\n}\n"]}