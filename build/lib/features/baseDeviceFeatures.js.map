{"version":3,"file":"baseDeviceFeatures.js","sourceRoot":"","sources":["../../../src/lib/features/baseDeviceFeatures.ts"],"names":[],"mappings":"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","sourcesContent":["// src/lib/features/base_device_features.ts\r\nimport type { Roborock } from \"../../main\";\r\nimport { Feature } from \"./features.enum\";\r\nimport { z } from \"zod\"; // Import Zod\r\n\r\n// --- Types & Interfaces ---\r\n\r\n/**\r\n * Specification for defining a command object's properties.\r\n */\r\nexport type CommandSpec = {\r\n\ttype: ioBroker.CommonType | \"json\"; // Internal type can be 'json' for logic\r\n\tdef?: any;\r\n\tstates?: Record<string | number, string>;\r\n\tmin?: number;\r\n\tmax?: number;\r\n\tunit?: string;\r\n\trole?: string;\r\n};\r\n\r\n/**\r\n * Type for a function that implements a specific feature.\r\n * It's called with the correct 'this' context bound.\r\n */\r\nexport type FeatureImplementation = () => Promise<void> | void;\r\n\r\n/**\r\n * Configuration provided by a specific model class.\r\n */\r\nexport interface DeviceModelConfig {\r\n\tstaticFeatures: Feature[]; // List of features this model always has\r\n}\r\n\r\n/**\r\n * Type for the constructor signature of a device feature class.\r\n */\r\nexport type FeatureClassConstructor = new (dependencies: FeatureDependencies, duid: string) => BaseDeviceFeatures;\r\n\r\n/**\r\n * Interface defining the dependencies injected into feature classes.\r\n */\r\nexport interface FeatureDependencies {\r\n\tadapter: Roborock;\r\n\tconfig: Roborock[\"config\"]; // Adapter configuration\r\n\thttp_api: Roborock[\"http_api\"]; // HTTP API helper instance\r\n\tensureState: Roborock[\"ensureState\"]; // Method reference for creating/ensuring states\r\n\tensureFolder: Roborock[\"ensureFolder\"]; // Method reference for ensuring folders\r\n\tlog: Roborock[\"log\"]; // Adapter log instance\r\n\t// Add other dependencies here if needed by feature implementations\r\n}\r\n\r\n// --- Registry & Decorator ---\r\n\r\n/** Central registry mapping robotModelId strings to feature class constructors. */\r\nconst modelRegistry = new Map<string, FeatureClassConstructor>();\r\n\r\n/**\r\n * Class decorator to register a feature class for a specific robot model ID.\r\n * @param robotModelId The unique model identifier string (e.g., 'roborock.vacuum.a70').\r\n */\r\nexport function RegisterModel(robotModelId: string) {\r\n\treturn function (constructor: FeatureClassConstructor) {\r\n\t\tif (modelRegistry.has(robotModelId)) {\r\n\t\t\t// Use console during the initial script load phase\r\n\t\t\tconsole.warn(`[Roborock Features] Model ${robotModelId} is already registered. Overwriting.`);\r\n\t\t}\r\n\t\tconsole.log(`[Roborock Features] Registering model: ${robotModelId}`);\r\n\t\tmodelRegistry.set(robotModelId, constructor);\r\n\t};\r\n}\r\n\r\n// --- Zod Schemas (Base) ---\r\n\r\n/**\r\n * Base Zod schema for validating generic status properties potentially common to all devices.\r\n */\r\nexport const BaseStatusSchema = z\r\n\t.object({\r\n\t\terror_code: z.number().int().optional(), // Example: error code might be generic\r\n\t\t// Add other truly generic status fields if applicable\r\n\t})\r\n\t.passthrough(); // Allow fields not defined in this schema\r\n\r\n// --- Generic Base Class ---\r\n\r\n/**\r\n * Abstract base class for handling device features.\r\n * Provides core logic for initialization, feature application, command object creation,\r\n * and dependency injection. Must be extended by device-type-specific base classes\r\n * (e.g., BaseVacuumFeatures).\r\n */\r\nexport abstract class BaseDeviceFeatures {\r\n\tprotected deps: FeatureDependencies;\r\n\tpublic commands: Record<string, CommandSpec | any>; // Holds the command definitions for this device instance\r\n\tprotected duid: string;\r\n\tprotected robotModel: string;\r\n\tprotected config: DeviceModelConfig; // Static feature configuration from the specific model class\r\n\tprotected appliedFeatures = new Set<Feature>(); // Tracks features already applied to this instance\r\n\tprotected runtimeDetectionComplete = false; // Flag: Initial runtime detection ran\r\n\tprotected commandsCreated = false; // Flag: Command objects created for ioBroker\r\n\r\n\t// --- Constants (Only absolutely generic ones) ---\r\n\tprotected static readonly CONSTANTS = {\r\n\t\t// Define constants universally applicable across all potential Roborock device types\r\n\t\tbaseCommands: {},\r\n\t\t// Generic error codes (subset)\r\n\t\terrorCodes: {\r\n\t\t\t0: \"No error\",\r\n\t\t\t255: \"Internal error\",\r\n\t\t\t\"-1\": \"Unknown Error\",\r\n\t\t\t// Add more if truly generic across all device types\r\n\t\t},\r\n\t};\r\n\r\n\t// --- Feature Registry (Static) ---\r\n\tprotected static featureRegistry = new Map<Feature, FeatureImplementation>();\r\n\tprotected static registryInitialized = false; // Ensures registration logic runs only once\r\n\r\n\t/**\r\n\t * Constructor for the base feature handler.\r\n\t * @param dependencies Injected dependencies (adapter, config, APIs, helpers).\r\n\t * @param duid The device unique identifier.\r\n\t * @param robotModel The robot model string.\r\n\t * @param config Configuration containing static features for this model.\r\n\t */\r\n\tconstructor(dependencies: FeatureDependencies, duid: string, robotModel: string, config: DeviceModelConfig) {\r\n\t\tthis.deps = dependencies;\r\n\t\tthis.duid = duid;\r\n\t\tthis.robotModel = robotModel;\r\n\t\tthis.config = config;\r\n\t\t// Start with generic base commands defined in this base class\r\n\t\tthis.commands = JSON.parse(JSON.stringify(BaseDeviceFeatures.CONSTANTS.baseCommands));\r\n\r\n\t\t// The registry is initialized only once, triggered by the first instance\r\n\t\t// of a *concrete* base class (like BaseVacuumFeatures) calling its `registerFeatures`.\r\n\t\tif (!BaseDeviceFeatures.registryInitialized) {\r\n\t\t\t// The flag is set here, but the actual registration happens in the concrete base class.\r\n\t\t\tBaseDeviceFeatures.registryInitialized = true;\r\n\t\t\tthis.deps.log.debug(\"Feature registry initialization flag set.\");\r\n\t\t}\r\n\t}\r\n\r\n\t// --- Abstract / Overridable Methods ---\r\n\r\n\t/**\r\n\t * Must be implemented by the concrete device-type base class (e.g., BaseVacuumFeatures)\r\n\t * to populate the static `featureRegistry` with all possible feature implementations for that type.\r\n\t */\r\n\tprotected abstract registerFeatures(): void;\r\n\r\n\t/**\r\n\t * Must be implemented by the concrete device-type base class to detect features\r\n\t * based on device-specific mechanisms (e.g., bitfields, firmware info).\r\n\t * @returns A Set containing the detected `Feature` enum keys (usually the 'is...' keys).\r\n\t */\r\n\tprotected abstract _getDynamicFeatures(): Set<Feature>;\r\n\r\n\t/**\r\n\t * Processes features related to the detected dock type.\r\n\t * Can be overridden by concrete base or specific model classes if needed.\r\n\t * @param dockType The numeric dock type identifier.\r\n\t */\r\n\tpublic async processDockType(dockType: number): Promise<void> {\r\n\t\tthis.deps.log.silly(`[${this.duid}] Base processDockType called for type ${dockType}. No default actions defined.`);\r\n\t\t// Default (base) implementation does nothing. Should be implemented in concrete base (e.g., BaseVacuumFeatures).\r\n\t}\r\n\r\n\t/**\r\n\t * Applies features defined statically in the `DeviceModelConfig`.\r\n\t * Can be overridden by specific model classes to add more complex model-specific logic\r\n\t * that runs *before* runtime detection.\r\n\t * @param statusData Optional initial status data.\r\n\t * @param fwFeatures Optional initial firmware features data.\r\n\t */\r\n\tpublic async applyModelSpecifics(statusData?: Readonly<Record<string, any>>, fwFeatures?: readonly number[]): Promise<void> {\r\n\t\tthis.deps.log.debug(`[FeatureApply|${this.robotModel}|${this.duid}] Applying model specifics (Static Features)...`);\r\n\t\tconst promises = this.config.staticFeatures.map((feature) => this.applyFeature(feature));\r\n\t\tawait Promise.all(promises);\r\n\t\tthis.deps.log.debug(`[FeatureApply|${this.robotModel}|${this.duid}] Finished applying model specifics.`);\r\n\t}\r\n\r\n\t/**\r\n\t * Must be implemented by the concrete device-type base class to perform\r\n\t * runtime feature detection based on validated status data.\r\n\t * @param statusData Validated status data object.\r\n\t * @param fwFeatures Optional firmware features data.\r\n\t * @returns `true` if features/commands were added or modified, `false` otherwise.\r\n\t */\r\n\tpublic abstract detectAndApplyRuntimeFeatures(statusData: Readonly<Record<string, any>>, fwFeatures?: readonly number[]): Promise<boolean>;\r\n\r\n\t// --- Core Initialization Logic ---\r\n\r\n\t/**\r\n\t * Initializes all features for the device instance according to the defined flow:\r\n\t * Model Specifics -> Runtime Detection -> Dock Processing -> Command Object Creation.\r\n\t * @param initialStatus Optional initial status data to use for detection.\r\n\t * @param initialFwFeatures Optional initial firmware features data.\r\n\t */\r\n\tpublic async initialize(initialStatus?: Readonly<Record<string, any>>, initialFwFeatures?: readonly number[]): Promise<void> {\r\n\t\tthis.deps.log.info(`[FeatureInit|${this.robotModel}|${this.duid}] Starting feature initialization...`);\r\n\r\n\t\t// Ensure registry is filled by the concrete base class implementation (runs only once).\r\n\t\t// This relies on the constructor setting the flag and the first instance calling registerFeatures.\r\n\t\tif (BaseDeviceFeatures.featureRegistry.size === 0 && BaseDeviceFeatures.registryInitialized) {\r\n\t\t\t// If the flag is set but registry is empty, the concrete implementation is missing the call.\r\n\t\t\tthis.deps.log.warn(\r\n\t\t\t\t`[FeatureInit|${this.robotModel}|${this.duid}] Registry initialization flag was set, but registry is empty. Ensure 'registerFeatures' is called in the constructor or initializer of the concrete base class (e.g., BaseVacuumFeatures).`\r\n\t\t\t);\r\n\t\t\t// Attempt to call it here as a fallback, but it should ideally happen earlier.\r\n\t\t\ttry {\r\n\t\t\t\tthis.registerFeatures(); // Call the *concrete* implementation now\r\n\t\t\t\tif (BaseDeviceFeatures.featureRegistry.size > 0) {\r\n\t\t\t\t\tthis.deps.log.info(`Feature registry initialized late via initialize(). Size: ${BaseDeviceFeatures.featureRegistry.size}`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.deps.log.error(`[FeatureInit|${this.robotModel}|${this.duid}] Failed to initialize feature registry even after explicit call!`);\r\n\t\t\t\t\treturn; // Abort initialization if registry fails\r\n\t\t\t\t}\r\n\t\t\t} catch (e: any) {\r\n\t\t\t\tthis.deps.log.error(`[FeatureInit|${this.robotModel}|${this.duid}] Error calling registerFeatures: ${e.message} ${e.stack}`);\r\n\t\t\t\treturn; // Abort\r\n\t\t\t}\r\n\t\t} else if (BaseDeviceFeatures.featureRegistry.size === 0 && !BaseDeviceFeatures.registryInitialized) {\r\n\t\t\t// Should not happen if constructor sets the flag correctly.\r\n\t\t\tthis.deps.log.error(`[FeatureInit|${this.robotModel}|${this.duid}] Registry initialization logic error: Flag not set and registry empty.`);\r\n\t\t\treturn; // Abort\r\n\t\t}\r\n\r\n\t\t// Flow: Basis -> Typ -> Spezifisch -> Laufzeit -> Dock\r\n\r\n\t\t// 1. Apply Model Specifics (Static Flags + Model Class Overrides/Additions)\r\n\t\ttry {\r\n\t\t\tawait this.applyModelSpecifics(initialStatus, initialFwFeatures);\r\n\t\t} catch (e: any) {\r\n\t\t\tthis.deps.log.error(`[FeatureInit|${this.robotModel}|${this.duid}] Error applying model specifics: ${e.message} ${e.stack}`);\r\n\t\t}\r\n\r\n\t\t// 2. Runtime Detection (implemented by concrete base like BaseVacuumFeatures)\r\n\t\tlet commandsChangedByRuntime = false;\r\n\t\tif (initialStatus) {\r\n\t\t\ttry {\r\n\t\t\t\tcommandsChangedByRuntime = await this.detectAndApplyRuntimeFeatures(initialStatus, initialFwFeatures);\r\n\t\t\t\tthis.runtimeDetectionComplete = true; // Mark initial detection attempt as done\r\n\t\t\t} catch (e: any) {\r\n\t\t\t\tthis.deps.log.error(`[FeatureInit|${this.robotModel}|${this.duid}] Error during runtime feature detection: ${e.message} ${e.stack}`);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.deps.log.warn(`[FeatureInit|${this.robotModel}|${this.duid}] Initial status data missing, skipping runtime feature detection.`);\r\n\t\t}\r\n\r\n\t\t// 3. Process Dock Type (implementation from concrete base or model class)\r\n\t\tif (initialStatus?.dock_type !== undefined) {\r\n\t\t\ttry {\r\n\t\t\t\tawait this.processDockType(initialStatus.dock_type);\r\n\t\t\t} catch (e: any) {\r\n\t\t\t\tthis.deps.log.error(`[FeatureInit|${this.robotModel}|${this.duid}] Error processing dock type ${initialStatus.dock_type}: ${e.message} ${e.stack}`);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.deps.log.debug(`[FeatureInit|${this.robotModel}|${this.duid}] Initial dock_type missing.`);\r\n\t\t}\r\n\r\n\t\t// 4. Create/Update ioBroker Objects for Commands\r\n\t\ttry {\r\n\t\t\tawait this.createCommandObjects();\r\n\t\t} catch (e: any) {\r\n\t\t\tthis.deps.log.error(`[FeatureInit|${this.robotModel}|${this.duid}] Error creating command objects: ${e.message} ${e.stack}`);\r\n\t\t}\r\n\r\n\t\tthis.deps.log.info(`[FeatureInit|${this.robotModel}|${this.duid}] Initialization complete.`);\r\n\t}\r\n\r\n\t// --- Core Helper Methods ---\r\n\r\n\t/**\r\n\t * Applies a single feature by looking up and executing its implementation from the registry.\r\n\t * Ensures a feature is applied only once per instance.\r\n\t * @param feature The Feature enum key to apply.\r\n\t * @returns `true` if the feature was successfully applied now, `false` otherwise.\r\n\t */\r\n\tprotected async applyFeature(feature: Feature): Promise<boolean> {\r\n\t\t// Basic validation of the input feature enum value\r\n\t\tif (!feature || !Object.values(Feature).includes(feature)) {\r\n\t\t\tthis.deps.log.warn(`[${this.duid}] Attempted to apply invalid feature value: ${feature}`);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t// Check if already applied\r\n\t\tif (this.appliedFeatures.has(feature)) {\r\n\t\t\tthis.deps.log.silly(`[${this.duid}] Feature '${feature}' already applied.`);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tconst implementation = BaseDeviceFeatures.featureRegistry.get(feature);\r\n\t\tif (implementation) {\r\n\t\t\tthis.deps.log.debug(`[FeatureApply|${this.robotModel}|${this.duid}] Applying feature '${feature}'...`);\r\n\t\t\ttry {\r\n\t\t\t\t// Use .call(this) to bind 'this' context and execute\r\n\t\t\t\tawait implementation.call(this);\r\n\t\t\t\tthis.appliedFeatures.add(feature); // Mark as applied *after* successful execution\r\n\t\t\t\tthis.deps.log.debug(`[FeatureApply|${this.robotModel}|${this.duid}] Successfully applied feature '${feature}'.`);\r\n\t\t\t\treturn true;\r\n\t\t\t} catch (e: any) {\r\n\t\t\t\tthis.deps.log.error(`[FeatureApply|${this.robotModel}|${this.duid}] Error applying feature '${feature}': ${e.message} ${e.stack}`);\r\n\t\t\t\treturn false; // Application failed\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.deps.log.warn(`[FeatureApply|${this.robotModel}|${this.duid}] No implementation registered for feature '${feature}'.`);\r\n\t\t\treturn false; // No implementation found\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Helper to map a dynamically detected feature key (e.g., from bitfield/fw, often starting with 'is...')\r\n\t * to the corresponding primary action Feature key (e.g., 'MopWash') if a mapping exists and is registered.\r\n\t * @param detectedFeature The Feature enum key detected dynamically.\r\n\t * @returns The mapped action Feature enum key, the detected key itself if it's directly actionable, or null.\r\n\t */\r\n\tprotected mapFeature(detectedFeature: Feature): Feature | null {\r\n\t\t// Try direct mapping: Check if the value of the 'is...' key (e.g., 'MopWash') exists as an enum key\r\n\t\tconst potentialActionName = Feature[detectedFeature as keyof typeof Feature]; // Get string value (e.g., 'MopWash')\r\n\t\t// Find the enum key that corresponds to this string value, EXCLUDING the original detected key itself\r\n\t\tconst mappedActionKey = (Object.keys(Feature) as Array<keyof typeof Feature>).find((key) => Feature[key] === potentialActionName && key !== detectedFeature);\r\n\r\n\t\tif (mappedActionKey) {\r\n\t\t\tconst actionFeatureEnum = Feature[mappedActionKey]; // Get the actual enum value (like Feature.MopWash)\r\n\t\t\t// Check if this mapped action feature *has an implementation registered*\r\n\t\t\tif (BaseDeviceFeatures.featureRegistry.has(actionFeatureEnum)) {\r\n\t\t\t\tthis.deps.log.silly(`[${this.duid}] Mapping dynamic feature '${detectedFeature}' to action '${actionFeatureEnum}'`);\r\n\t\t\t\treturn actionFeatureEnum;\r\n\t\t\t} else {\r\n\t\t\t\tthis.deps.log.silly(`[${this.duid}] Dynamic feature '${detectedFeature}' mapped to '${actionFeatureEnum}', but no action is registered for it.`);\r\n\t\t\t\treturn null; // Mapped but no action\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If no mapping, check if the detected feature key itself has a registered action\r\n\t\tif (BaseDeviceFeatures.featureRegistry.has(detectedFeature)) {\r\n\t\t\tthis.deps.log.silly(`[${this.duid}] Using dynamic feature '${detectedFeature}' directly as it has a registered action.`);\r\n\t\t\treturn detectedFeature;\r\n\t\t}\r\n\r\n\t\t// If neither mapping nor direct action found, it's likely just a flag or unhandled\r\n\t\tthis.deps.log.silly(`[${this.duid}] Dynamic feature '${detectedFeature}' detected but has no registered action or mapping.`);\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates or updates all command state objects in ioBroker based on the current `this.commands` map.\r\n\t */\r\n\tpublic async createCommandObjects(): Promise<void> {\r\n\t\tconst folderPath = `Devices.${this.duid}.commands`;\r\n\t\t// Ensure folder exists *before* creating states in parallel\r\n\t\ttry {\r\n\t\t\tawait this.deps.ensureFolder(folderPath);\r\n\t\t} catch (e: any) {\r\n\t\t\tthis.deps.log.error(`[${this.duid}] Failed to ensure commands folder ${folderPath}: ${e.message}`);\r\n\t\t\treturn; // Abort if folder cannot be ensured\r\n\t\t}\r\n\r\n\t\tthis.deps.log.debug(`[${this.duid}] Creating/Updating ${Object.keys(this.commands).length} command objects...`);\r\n\t\tconst promises: Promise<void>[] = [];\r\n\r\n\t\tfor (const [command, commonCommand] of Object.entries(this.commands)) {\r\n\t\t\t// Use an async IIFE (Immediately Invoked Function Expression) for safe parallel execution within the loop\r\n\t\t\tpromises.push(\r\n\t\t\t\t(async (cmd: string, spec: CommandSpec | any) => {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tconst options: Partial<ioBroker.StateCommon> = {\r\n\t\t\t\t\t\t\t...(spec as Partial<ioBroker.StateCommon>),\r\n\t\t\t\t\t\t\tname: spec.name || this.deps.adapter.translations[cmd] || cmd, // Add name generation/translation\r\n\t\t\t\t\t\t\twrite: true, // Commands must be writable\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tconst originalType = spec.type; // Store original type ('json' etc.)\r\n\r\n\t\t\t\t\t\t// Determine Role if not explicitly set in spec\r\n\t\t\t\t\t\tif (!options.role) {\r\n\t\t\t\t\t\t\tif (originalType === \"boolean\" && !options.states) options.role = \"button\";\r\n\t\t\t\t\t\t\telse if (originalType === \"number\" && options.states) options.role = \"value.list\";\r\n\t\t\t\t\t\t\telse if (originalType === \"number\") options.role = \"level\";\r\n\t\t\t\t\t\t\telse if (originalType === \"json\" && options.states) options.role = \"value.list\";\r\n\t\t\t\t\t\t\telse if (originalType === \"json\") options.role = \"json\";\r\n\t\t\t\t\t\t\telse options.role = \"state\";\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Adjust type for ioBroker\r\n\t\t\t\t\t\tif (originalType === \"json\") {\r\n\t\t\t\t\t\t\toptions.type = \"string\";\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Final type validation and default\r\n\t\t\t\t\t\tconst validTypes: ioBroker.CommonType[] = [\"string\", \"number\", \"boolean\", \"object\", \"array\", \"mixed\"];\r\n\t\t\t\t\t\tif (!options.type || typeof options.type !== \"string\" || !validTypes.includes(options.type as ioBroker.CommonType)) {\r\n\t\t\t\t\t\t\tif (originalType !== \"json\") {\r\n\t\t\t\t\t\t\t\t// Avoid redundant log if we just set it to string\r\n\t\t\t\t\t\t\t\tthis.deps.log.warn(`[${this.duid}] Invalid or missing type '${spec.type}' for command '${cmd}', defaulting to 'string'.`);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\toptions.type = \"string\";\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tconst path = `${folderPath}.${cmd}`;\r\n\r\n\t\t\t\t\t\t// Create or Update Object\r\n\t\t\t\t\t\tconst existingObj = await this.deps.adapter.getObjectAsync(path);\r\n\t\t\t\t\t\tif (existingObj) {\r\n\t\t\t\t\t\t\t// Only extend if common differs significantly (simple stringify might be too sensitive)\r\n\t\t\t\t\t\t\t// A more robust check might compare key properties individually. For now, stringify is pragmatic.\r\n\t\t\t\t\t\t\tif (JSON.stringify(existingObj.common) !== JSON.stringify(options)) {\r\n\t\t\t\t\t\t\t\tthis.deps.log.silly(`[${this.duid}] Extending command object ${path}`);\r\n\t\t\t\t\t\t\t\tawait this.deps.adapter.extendObject(path, { common: options as ioBroker.StateCommon });\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tthis.deps.log.silly(`[${this.duid}] Command object ${path} common part is up-to-date.`);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.deps.log.silly(`[${this.duid}] Ensuring command object ${path}`);\r\n\t\t\t\t\t\t\tawait this.deps.ensureState(path, options as ioBroker.StateCommon);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Reset button states after ensuring object exists/is updated\r\n\t\t\t\t\t\tif (options.role === \"button\") {\r\n\t\t\t\t\t\t\tconst currentState = await this.deps.adapter.getStateAsync(path);\r\n\t\t\t\t\t\t\t// Set to false only if not already false or if state doesn't exist yet\r\n\t\t\t\t\t\t\tif (!currentState || currentState.val !== false) {\r\n\t\t\t\t\t\t\t\tawait this.deps.adapter.setState(path, false, true);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} catch (e: any) {\r\n\t\t\t\t\t\tthis.deps.log.error(`[${this.duid}] Error processing command object '${command}': ${e.message}`);\r\n\t\t\t\t\t\t// Optional: Log stack trace for more details: this.deps.log.error(e.stack);\r\n\t\t\t\t\t}\r\n\t\t\t\t})(command, commonCommand)\r\n\t\t\t); // Pass command and spec to IIFE\r\n\t\t} // End for loop\r\n\r\n\t\ttry {\r\n\t\t\tawait Promise.all(promises); // Wait for all command object operations\r\n\t\t\tthis.commandsCreated = true; // Mark as done for this run\r\n\t\t\tthis.deps.log.debug(`[${this.duid}] Command object creation/update finished.`);\r\n\t\t} catch (e: any) {\r\n\t\t\t// Errors inside the IIFEs are caught individually, this catches errors from Promise.all itself (rare)\r\n\t\t\tthis.deps.log.error(`[${this.duid}] Critical error during parallel command object creation: ${e.message}`);\r\n\t\t}\r\n\t}\r\n\r\n\t// --- Helper Methods ---\r\n\r\n\t/**\r\n\t * Adds or updates a command definition in the instance's `commands` map.\r\n\t * Includes logic to merge `states` to prevent overwriting more specific definitions.\r\n\t * @param name The name (key) of the command.\r\n\t * @param spec The `CommandSpec` definition for the command.\r\n\t */\r\n\tprotected _addCommand(name: string, spec: CommandSpec | any): void {\r\n\t\tif (!name || typeof name !== \"string\") {\r\n\t\t\tthis.deps.log.error(`[${this.duid}] _addCommand: Invalid command name provided: ${name}`);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\t// Merge states logic: If new spec has fewer states than existing, merge them preserving existing ones.\r\n\t\t\tif (this.commands[name]?.states && spec.states) {\r\n\t\t\t\tconst existingStatesJson = JSON.stringify(this.commands[name].states);\r\n\t\t\t\tconst newStatesJson = JSON.stringify(spec.states);\r\n\t\t\t\tif (existingStatesJson !== newStatesJson) {\r\n\t\t\t\t\tthis.deps.log.silly(`[${this.duid}] Command '${name}' merge: Merging states.`);\r\n\t\t\t\t\t// Merge: New states overwrite/add to existing ones\r\n\t\t\t\t\tspec.states = { ...this.commands[name].states, ...spec.states };\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// If states are identical, ensure the rest of the existing spec isn't lost if the new one is simpler\r\n\t\t\t\t\tspec = { ...this.commands[name], ...spec, states: this.commands[name].states };\r\n\t\t\t\t}\r\n\t\t\t} else if (this.commands[name]?.states && !spec.states) {\r\n\t\t\t\t// If existing had states but new one doesn't, keep existing states\r\n\t\t\t\tspec.states = this.commands[name].states;\r\n\t\t\t}\r\n\t\t\tthis.commands[name] = spec;\r\n\t\t\tthis.deps.log.silly(`[${this.duid}] Added/Updated command '${name}'`);\r\n\t\t} catch (e: any) {\r\n\t\t\tthis.deps.log.error(`[${this.duid}] Error in _addCommand for '${name}': ${e.message}`);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Helper to call the injected `ensureState` function with the correct path format.\r\n\t * @param subfolder The subfolder within the device structure (e.g., 'info', 'commands').\r\n\t * @param stateName The name of the state.\r\n\t * @param commonOptions State common options.\r\n\t * @param native Optional native options.\r\n\t */\r\n\tprotected async _ensureState(subfolder: string, stateName: string, commonOptions: Partial<ioBroker.StateCommon>, native: Record<string, any> = {}): Promise<void> {\r\n\t\tconst path = `Devices.${this.duid}.${subfolder}.${stateName}`;\r\n\t\ttry {\r\n\t\t\t// Ensure type is valid before calling ensureState\r\n\t\t\tconst validTypes: ioBroker.CommonType[] = [\"string\", \"number\", \"boolean\", \"object\", \"array\", \"mixed\"];\r\n\t\t\tif (commonOptions.type && !validTypes.includes(commonOptions.type as ioBroker.CommonType)) {\r\n\t\t\t\tthis.deps.log.warn(`[${this.duid}] Invalid type '${commonOptions.type}' in _ensureState for ${path}, defaulting to 'string'.`);\r\n\t\t\t\tcommonOptions.type = \"string\";\r\n\t\t\t}\r\n\t\t\tawait this.deps.ensureState(path, commonOptions as ioBroker.StateCommon, native); // Cast after validation\r\n\t\t} catch (e: any) {\r\n\t\t\tthis.deps.log.error(`[${this.duid}] Error in _ensureState for ${path}: ${e.message}`);\r\n\t\t}\r\n\t}\r\n\r\n\t// --- Static Methods ---\r\n\r\n\t/**\r\n\t * Retrieves the registered feature class constructor for a given model ID.\r\n\t * @param modelId The robot model identifier string.\r\n\t * @returns The constructor if found, otherwise undefined.\r\n\t */\r\n\tpublic static getRegisteredModelClass(modelId: string): FeatureClassConstructor | undefined {\r\n\t\treturn modelRegistry.get(modelId);\r\n\t}\r\n\r\n\t/**\r\n\t * Public method to check if a specific static feature is defined\r\n\t * in this model's configuration.\r\n\t * @param feature The Feature enum key to check.\r\n\t * @returns `true` if the feature is listed in staticFeatures, `false` otherwise.\r\n\t */\r\n\tpublic hasStaticFeature(feature: Feature): boolean {\r\n\t\treturn this.config.staticFeatures.includes(feature);\r\n\t}\r\n\r\n\t// --- Instance Getters for Constants (Abstract Declarations) ---\r\n\t// These must be implemented by the concrete device-type base class (e.g., BaseVacuumFeatures)\r\n\t// to provide access to type-specific constants.\r\n\r\n\tpublic abstract getCommonConsumable(attribute: string | number): Partial<ioBroker.StateCommon> | undefined;\r\n\tpublic abstract isResetableConsumable(consumable: string): boolean;\r\n\tpublic abstract getCommonDeviceStates(attribute: string | number): Partial<ioBroker.StateCommon> | undefined;\r\n\tpublic abstract getCommonCleaningRecords(attribute: string | number): Partial<ioBroker.StateCommon> | undefined;\r\n\tpublic abstract getFirmwareFeatureName(featureID: string | number): string;\r\n\tpublic abstract getCommonCleaningInfo(attribute: string | number): Partial<ioBroker.StateCommon> | undefined;\r\n}\r\n"]}