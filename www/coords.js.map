{"version":3,"file":"coords.js","sourceRoot":"","sources":["../src/www/coords.ts"],"names":[],"mappings":"AAAA,oBAAoB;AAEpB,wDAAwD;AACxD,MAAM,YAAY,GAAG,EAAE,CAAC;AAexB,MAAM,CAAC,MAAM,iBAAiB,GAAG,CAAC,CAAC;AACnC,MAAM,CAAC,MAAM,kBAAkB,GAAG,iBAAiB,GAAG,CAAC,CAAC;AAExD;;;GAGG;AACH,MAAM,UAAU,wBAAwB,CAAC,UAAiB,EAAE,MAAiB;IAC5E,IAAI,CAAC,MAAM;QAAE,OAAO,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;IAEnC,6CAA6C;IAC7C,4CAA4C;IAC5C,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,GAAG,kBAAkB,CAAC,GAAG,MAAM,CAAC,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,YAAY,CAAC,CAAC;IAEnH,wEAAwE;IACxE,uEAAuE;IACvE,iEAAiE;IACjE,uDAAuD;IACvD,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,WAAW,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,kBAAkB,CAAC,CAAC,GAAG,MAAM,CAAC,WAAW,CAAC,GAAG,YAAY,CAAC,CAAC;IAE7I,OAAO,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC;AACjC,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,wBAAwB,CAAC,UAAiB,EAAE,MAAiB;IAC5E,IAAI,CAAC,MAAM;QAAE,OAAO,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;IAEnC,gFAAgF;IAChF,qEAAqE;IACrE,MAAM,YAAY,GAAG,iBAAiB,CAAC;IAEvC,4DAA4D;IAC5D,MAAM,OAAO,GAAG,kBAAkB,CAAC;IAEnC,sEAAsE;IACtE,MAAM,OAAO,GAAG,CAAC,kBAAkB,CAAC;IAEpC,8CAA8C;IAC9C,MAAM,MAAM,GAAG,CAAC,UAAU,CAAC,CAAC,GAAG,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,YAAY,GAAG,OAAO,CAAC;IAEpF,oDAAoD;IACpD,MAAM,MAAM,GAAG,CAAC,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,WAAW,GAAG,UAAU,CAAC,CAAC,GAAG,YAAY,CAAC,GAAG,YAAY,GAAG,OAAO,CAAC;IAE3G,OAAO,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC;AACjC,CAAC","sourcesContent":["// src/www/coords.ts\r\n\r\n// The true physical scale (50mm/pixel) used by Roborock\r\nconst MM_PER_PIXEL = 50;\r\n\r\ninterface Point {\r\n\tx: number;\r\n\ty: number;\r\n}\r\n\r\n// Map parameters required for the calculations\r\ninterface MapParams {\r\n\tscaleFactor: number; // Config scale (e.g., 8) - used for visual scaling only\r\n\tleft: number; // Unscaled Pixel Offset X\r\n\ttopMap: number; // Unscaled Pixel Offset Y\r\n\timageHeight: number; // Unscaled Pixel Height\r\n}\r\n\r\nexport const VISUAL_BLOCK_SIZE = 3;\r\nexport const GRID_CENTER_OFFSET = VISUAL_BLOCK_SIZE / 2;\r\n\r\n/**\r\n * Converts LOCAL \"world\" pixel coordinates (px, Y-down) back to ROBOT coordinates (mm).\r\n * Used for Click-Tests, GoTo, and Zones.\r\n */\r\nexport function localCoordsToRobotCoords(localPoint: Point, params: MapParams): Point {\r\n\tif (!params) return { x: 0, y: 0 };\r\n\r\n\t// X-Axis: (Unscaled Pixel X + Offset X) * 50\r\n\t// Inverse of Draw: (Point - Offset) / Scale\r\n\tconst robotX = Math.round(((localPoint.x - GRID_CENTER_OFFSET) / params.scaleFactor + params.left) * MM_PER_PIXEL);\r\n\r\n\t// Y-Axis (Inverted Logic): ((H_px + top_px) - (Y_px - Offset) / s) * 50\r\n\t// Note: imageHeight is already unscaled, do NOT divide by scaleFactor.\r\n\t// Inverse of Draw (Y): (Top + Height - Y_mm/50) * Scale + Offset\r\n\t// => Y_mm/50 = Top + Height - (Y_pix - Offset) / Scale\r\n\tconst robotY = Math.round((params.imageHeight + params.topMap - (localPoint.y - (-GRID_CENTER_OFFSET)) / params.scaleFactor) * MM_PER_PIXEL);\r\n\r\n\treturn { x: robotX, y: robotY };\r\n}\r\n\r\n/**\r\n * Converts ROBOT coordinates (mm) to LOCAL \"world\" pixel coordinates (px, Y-down).\r\n * This is used to DRAW things on the map.\r\n */\r\nexport function robotCoordsToLocalCoords(robotPoint: Point, params: MapParams): Point {\r\n\tif (!params) return { x: 0, y: 0 };\r\n\r\n\t// The map image is generated with 3 pixels per grid unit (VISUAL_BLOCK_SIZE=3).\r\n\t// So we must scale the coordinates by 3 to match the image features.\r\n\tconst correctScale = VISUAL_BLOCK_SIZE;\r\n\r\n\t// X-Axis: Center in the middle of the grid block (0 -> 1.5)\r\n\tconst offsetX = GRID_CENTER_OFFSET;\r\n\r\n\t// Y-Axis: Center in the middle of the grid block (0 -> -1.5 inverted)\r\n\tconst offsetY = -GRID_CENTER_OFFSET;\r\n\r\n\t// X-Axis: (mm / 50 - Params) * Scale + Offset\r\n\tconst worldX = (robotPoint.x / MM_PER_PIXEL - params.left) * correctScale + offsetX;\r\n\r\n\t// Y-Axis: (Top + Height - Y_mm/50) * Scale + Offset\r\n\tconst finalY = (params.topMap + params.imageHeight - robotPoint.y / MM_PER_PIXEL) * correctScale + offsetY;\r\n\r\n\treturn { x: worldX, y: finalY };\r\n}\r\n"]}